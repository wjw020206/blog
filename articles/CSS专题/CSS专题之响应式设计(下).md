# CSS专题之响应式设计(下)



## 前言

> 石匠敲击石头的第 11 次

上一篇文章我们讲了什么是响应式设计以及响应式设计一些相关的概念，并分别用三种方案实现了一个拥有响应式设计的网页。今天这篇文章我将着重讲移动端适配、资源（如图片、字体）适配。



## 什么是移动端适配

移动端发展至今，各种移动设备的尺寸五花八门，但 UI 设计师通常只会提供大小固定的设计稿（例如尺寸为`750px * 1334px` 的设计稿），所以前端不得不面对一个问题，**如何让基于一份设计稿制作的页面，在不同移动设备上保持一致的展示效果？**

![image-20250428084738708](images/image-20250428084738708.gif)

虽然我们上一篇文章中提到了 **CSS 媒体查询**，可以让网页在不同屏幕尺寸下自适应布局，但如果想要在不同设备上**做到像素级别接近设计稿的还原效果**，光靠媒体查询远远不够，所以才有了移动端适配。

**移动端适配就是让网页在不同尺寸、不同分辨率的移动设备上，都能保持良好的布局和视觉效果的一种技术处理。**



## 基础概念

在讲移动端适配方案之前，我们需要先理解一些基础概念。



### 设备独立像素

下图大家应该都很熟悉，就是 Chrome 开发者工具，这里我们选用了 iPhone 6/7/8，可以看到中间部分显示的是 `375 × 667`。

![image-20250429075246066](images/image-20250429075246066.png)

那么这里的 `375 X 667` 到底是什么意思？这里表示的是**设备独立像素（Device Independent Pixel，简称 DIP）**，也可以理解为是 **CSS 像素** 或者 **逻辑像素**。

通常来说，当我们在 CSS 中给一个元素设置尺寸，例如 `width: 100px; height: 100px;`，实际上是设置了它的**设备独立像素大小**。

**设备独立像素 = CSS 像素 = 逻辑像素**



### 物理像素

以苹果官网[iPhone 6 - 技术规格](https://support.apple.com/zh-cn/111954)文档为例，在显示屏一栏中可以看到 `1334 x 750` 像素分辨率。

![image-20250429082924314](images/image-20250429082924314.png)

这里的 `1334 x 750` 像素分辨率指的是屏幕的**物理像素（Physical Pixel）**，也可以理解为是 **设备像素**，在同一个设备中，物理像素的固定的，当屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，`1334 x 750` 表示屏幕在垂直和水平上的物理像素点数。

**物理像素 = 设备像素**



###  设备像素比

知道了前面的 **设备独立像素** 和 **物理像素** 的概念后，就可以更好的理解**设备像素比（Device Pixel Ratio，简称 DPR）**。

设备像素比指的是**未缩放状态下**，物理像素和设备独立像素的初始比值关系。

DPR 的计算公式如下：

![image-20250429084514069](images/image-20250429084514069.png)

以 iPhone 6 为例：

- 物理像素是 `750 X 1334`
- 设备独立像素是 `375 X 667`

所以它的宽度像素比计算如下：

![image-20250429085253676](images/image-20250429085253676.png)

在高度方向上计算也是一样的：

![image-20250429085404825](images/image-20250429085404825.png)

所以我们可以得出 **iPhone 6 的设备像素比（DPR）是 2**。

表示在 iPhone 6 中 **每一个设备独立像素（CSS像素）由 2 × 2 = 4 个物理像素组成**，这也就是我们常说的**视网膜显示屏（Retina Display）。**

视网膜显示屏是苹果公司设计和委托制造的显示屏幕，`DPR > 1` 的屏幕都可以被称为视网膜显示屏。

![image-20250430073739678](images/image-20250430073739678.png)

在视网膜屏中，由多个像素来代替原来一个像素，可以使得元素看起来更精致，但元素本身的大小没有改变。

![image-20250430074205826](images/image-20250430074205826.png)

在 Chrome 开发者工具中，我们可以看到设备对应的 DPR。

![image-20250430074431892](images/image-20250430074431892.png)

也可以在自适应模式中自定义设备的 DPR。

![image-20250430074532563](images/image-20250430074532563.png)



### 像素密度

![image-20250430075732391](images/image-20250430075732391.png)

在前面的图中我们还注意到一项重要的参数 `326 ppi`，这就是 **PPI（Pixels Per Inch）**，表示每英寸所包含的像素数量，也叫**像素密度**。**PPI 跟物理像素一样，也是从工厂出来那天起，就固定不变了**。

PPI 的计算公式如下：

![image-20250430080211782](images/image-20250430080211782.png)

还是以前面的 iPhone 6 为例：

- 分辨率（物理像素）： `750 X 1334`
- 屏幕尺寸：4.7 英寸

![image-20250430081252831](images/image-20250430081252831.png)

计算结果正好就是 326，与苹果官网参数一致，当时苹果公司给出的视网膜屏幕定义是：只要 PPI 超过了 300，人眼就再也识别不出来屏幕上的像素点了。



以下是相同屏幕大小，但像素密度不同的设备。

- 左边的设备像素较少（PPI 较低），所以文字边缘锯齿明显，看起来较模糊
- 右边的设备像素更多（PPI 较高），文字显示更平滑清晰，视觉体验更好

 **在屏幕大小不变的前提下，像素越密集，图像越清晰**。

![image-20250430081431530](images/image-20250430081431530.png)



### 视口

**视口（Viewport）**是浏览器显示页面内容的区域，这个概念最初由苹果公司在推出 iPhone 时引入，目的是为了在移动设备上也能良好展示传统为 PC 设计的网页 —— 即使网页原始尺寸较大，也能自动缩小适配屏幕。

在移动端浏览器中，存在以下三种视口：

- **布局视口（Layout Viewport）**
- **视觉视口（Visual Viewport）**
- **理想视口（Ideal Viewport）**



**布局视口**

![image-20250506155242040](images/image-20250506155242040.png)

布局视口是浏览器实际用于 CSS 布局的宽度，**当没有添加 `<meta name="viewport" ...>` 时，默认会采用布局视口的规则**，具体表现如下：

- 桌面端浏览器

  - **布局视口宽度默认等于浏览器窗口的宽度**（即 `window.innerWidth`）
  - 当用户调整浏览器窗口大小时，布局视口会同步发生变化

-  移动端浏览器

   -  默认布局视口宽度通常为 **`980px`**（不同浏览器之间略有不同，但普遍在 `800px ~1024px` 之间）

   -  **浏览器会按照 `980px` 的宽度渲染页面，然后再将整个页面缩小来适应手机屏幕宽度（例如 `375px` 的设备独立像素度）**

   -  用户看到的实际内容是缩放的，可能需要手动缩放或横向滚动才能阅读（因为字体被缩小了），就像下面这样

      ![image-20250506170414866](images/image-20250506170414866.png)




**视觉视口**

![image-20250506155308867](images/image-20250506155308867.png)

**视觉视口**就是用户当前实际看到的屏幕区域，受缩放和滚动影响。

- 如果用户放大页面，则视觉视口会变小（显示的内容更少）

  ![image-20250506171809727](images/image-20250506171809727.png)

- 如果缩小页面，则视觉视口会变大（显示的内容更多）

  ![image-20250506170414866](images/image-20250506170414866.png)



**理想视口**

![image-20250506155332633](images/image-20250506155332633.png)



浏览器会根据设备的特性，自动选择一个最合适的“理想布局视口宽度”，这个宽度通常等于该设备的**设备独立像素宽度**，也就是 `device-width`。

可以通过在 `<head>` 中添加如下 `<meta>` 标签，显式告诉浏览器使用理想视口

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

**这样一来布局视口的宽度就会等于理想视口的宽度，页面也不会被缩放**，如果对 `<meta>` 标签的用法感兴趣，可以看一下我之前写的这篇文章。

以 iPhone 6 为例，它的物理分辨率为 `750 × 1334`，DPR 为 `2`，那么其理想视口宽度为 `750 / 2 = 375`，即等于它的设备独立像素宽度。

例如掘金在理想视口下的布局

![image-20250506173524684](images/image-20250506173524684.png)



**实践建议**

- 在网页开发的时候建议**始终添加 `<meta name="viewport" ...>` 标签**，这样才能让 `布局视口 = 设备逻辑宽度`，以此确保响应式布局生效
- 不推荐在 `<meta name="viewport" ...>` 标签中添加 `user-scalable=no` 来禁止用户缩放，**可能影响无障碍体验**



## 移动端适配方案

在掌握了设备独立像素、物理像素、DPR 和 PPI 这些基础概念之后，我们终于可以回答一个关键问题：

> **移动端适配到底是在适配什么？**

我认为主要是适配以下两个方面：

- **适配不同屏幕尺寸：** 页面内容在大屏和小屏设备上都能合理展示，不出现溢出或留白
- **适配不同的 DPR：** 即 1 个 设备独立像素对应多少物理像素



### 适配不同屏幕尺寸

适配不同屏幕尺寸需要确保元素大小和屏幕大小保持一定比例，类似于按比例等比缩放元素大小来还原设计稿。

例如我们有标注尺寸为 `375 X 667` 大小的设计稿。

![image-20250504144456714](images/image-20250504144456714.png)

其中一个元素的大小为 `196 X 126`。

![image-20250504143625074](images/image-20250504143625074.png)

我们根据页面宽度为基准，计算出这个元素的大小在整个页面中的相对比例：

- 元素的宽度：`196 / 375 = 52.26%`
- 元素的高度：`126 / 375 = 33.6%`
- 其他如 `margin`、`padding`、`left` 等也可以用同样的方式换算为相对百分比

但可惜的是，百分比单位并不是万能的。我们在前文中提到过，`%` 在 CSS 中的**基准值依赖于属性和上下文**，并不总是直观或统一的。例如：

- `width` 使用百分比时，是相对于元素包含块的 `width`
- `margin` 和 `padding` 使用百分比时，无论是水平还是垂直方向，**统一都是基于包含块的 `width`**
- `height` 使用百分比时，常常需要父元素有明确的高度
- 某些定位属性如 `top` / `left` 的表现也不总一致……

这些差异会让使用 `%` 单位做响应式布局变得复杂。所以我们需要采用别的方案。



### rem

因为 `rem` 单位是基于 `html` 元素的字体大小来计算具体的值的，所以我们可以通过**动态设置 `html` 元素的 `font-size`** 来实现页面中所有使用 `rem` 单位的元素进行等比缩放。

[flexible](https://github.com/amfe/lib-flexible) 是阿里早期开源的一种移动端适配方案，它的核心思想非常简单：

> **将视口宽度平均分为 10 份，使得 `1rem = 视口宽度 / 10`。**

然后再通过 JavaScript 将计算结果设置给 `html` 元素的 `font-size`。这样我们就可以将设计稿上的 `px` 单位转换为 `rem` 单位。

以前面的设计稿为例：

- 设计稿宽度为 `375`，所以 `1rem = 375 / 10 = 37.5px`

- 元素大小为 `196 X 126`，通过以下计算来转换为 `rem` 单位

  - 宽度：`196 / 37.5 = 5.2267rem`
  - 高度：`126 / 37.5 = 3.36rem`
  - 其他如 `margin`、`padding`、`left` 等也可以用同样的方式换算为 `rem`

[在线预览效果](https://codepen.io/wjw020206/pen/raadELG)

![image-20250506175827793](images/image-20250506175827793.gif)

类似的方案还有 [hotcss](https://imochen.github.io/hotcss/)。



### vw

严格来说，使用 `rem` 适配移动端页面是一种 **hack 手段**，因为 `rem` 单位的初衷不是用来进行移动端布局的，就连 [flexible](https://github.com/amfe/lib-flexible) 这个曾经非常流行的适配方案，在它的首页也明确表示**该方案已不再推荐使用，官方建议采用基于 `vw` 的新方案**。

![image-20250507074211273](images/image-20250507074211273.png)

使用 `rem` 适配的方案是不错，但是需要依赖 JavaScript 动态修改根元素的 `font-size`，而 `vw/vh（vmax/vmin）` 的出现很好的弥补了需要 JavaScript 辅助的缺点。

**`1vw` 等于 `window.innerWidth` 的数值的 `1%`**

**`1vh` 等于`window.innerHeight` 的数值的 `1%`**

还是以前面的设计稿为例：

- 设计稿宽度为 `375`

- 元素大小为 `196 X 126`，通过以下计算来转换为 `vw` 单位

  - 宽度：`196 / 375 = 52.2667vw`
  - 高度：`126 / 375 = 33.6vw`
  - 其他如 `margin`、`padding`、`left` 等也可以用同样的方式换算为 `vw`

[在线预览效果](https://codepen.io/wjw020206/pen/qEEKXEL)



### 图片适配及优化

图片通常是**页面中最占流量、加载最慢的资源之一**，在移动端中这种问题尤为明显，既影响加载速度，也影响用户体验。

通常我们有以下优化手段：

1. **去除无用图片资源**：删除冗余图片、避免加载未展示的图像
2. **选择合适的图片格式**：例如 WebP、AVIF 等更高效的现代格式
3. **使用矢量图（SVG/CSS3）代替部分位图**：图标、简单图形建议用 SVG
4. **按 DPR 提供多种分辨率图片**：结合 `srcset` 和 `sizes` 让浏览器自动选择
5. **图片懒加载**：只在用户滚动到时才加载图片，减少首屏体积
6. **使用 CDN 缓存和压缩服务**：提升加载速度，减小文件大小



本文主要聚焦的是第四点：**为不同 DPR 提供合适分辨率的图片资源**。

假设在移动端页面中有一张尺寸为 `200 × 400` 的图片（CSS 像素），在不同设备上由于 DPR（设备像素比）不同，实际需要加载的图片像素尺寸也不同：

- 对于 DPR = 1 的设备，需要加载一张 `200 × 400` 的图片

- DPR = 2 时，需要 `400 × 800`

- DPR = 3 时，则需要 `600 × 1200`

如果我们为了省事，直接统一使用三倍图（`600 × 1200`），虽然能保证在高分屏下足够清晰，但在低分辨率设备上却会**带来不必要的带宽浪费**，影响加载速度和用户体验。

好在现代浏览器支持使用 `<img>` 标签的 `srcset` 和 `sizes` 属性，让我们可以**为不同 DPR 提供不同分辨率的图片**，由浏览器自动选择最合适的图片进行加载。



**使用 srcset 属性适配 DPR**

```html
<img 
  src="img@1x.jpg"
  srcset="img@1x.jpg 1x, img@2x.jpg 2x, img@3x.jpg 3x"
/>
```

上述代码中的 `1x`、`2x`、`3x` 表示**设备像素比描述符**

- 当屏幕的 DPR = 1 时，使用 `img@1x.jpg` 这张图
- 当屏幕的 DPR = 2 时，使用 `img@2x.jpg` 这张图
- 当屏幕的 DPR = 3 时，使用 `img@3x.jpg` 这张图

**⚠️ 注意：** 如果当前浏览器不支持 `srcset` 属性，则退回使用 `src` 中配置图片，上述代码就是会退回使用 `img@1x.jpg` 这张图。



**使用 srcset 属性的 w 宽度描述符配合 sizes 属性**

`w` 描述符用于表示图片资源的**实际 CSS 像素宽度**，而 `sizes` 属性告诉浏览器在不同的视口条件下，图片将会占据多宽的布局空间。浏览器会基于这些信息，自动选择最合适的图片资源进行加载。

```html
<img
  sizes="(min-width: 600px) 600px, 300px"
  src="img@1x.jpg"
  srcset="img@1x.jpg 300w,
     			img@2x.jpg 600w,
     			img@3x.jpg 1200w"
/>
```

上面这段代码，浏览器首先会根据当前视口的宽度来解析 `sizes="(min-width: 600px) 600px, 300px"`，判断图片在当前布局下应该占据多少像素的宽度。

- 当视口宽度大于等于 `600px` 时，则图片的**展示宽度为 `600px` **
- 反之（视口宽度小于 `600px` 时），图片的**展示宽度为 `300px` **

**⚠️ 注意：** 这里的**展示宽度**是浏览器**用于选择资源的参考值**，并不意味着图片的实际宽度会随之改变，如果希望图片在不同视口下真实显示出不同的宽度，还需要通过 CSS 或 JavaScript 显式设置其样式。



接下来就是看 `srcset="img@1x.jpg 300w, img@2x.jpg 600w, img@3x.jpg 1200w"`，里面的 `300w`、`600w`、`1200w` 表示**宽度描述符**，需要结合前面的 `sizes` 属性确定的值进行计算，计算过程如下：

**假设视口宽度为 `375px`，DPR = 2**

1. 浏览器首先根据 `sizes` 属性判断图片在当前视口下的**展示宽度**为 `300px`
2. 然后将 `srcset` 中的每张图片的实际宽度除以展示宽度，计算其**等效 DPR**
   1. `300w / 300px = 1`
   2. `600w / 300px = 2`
   3. `1200w / 300px = 4`
3. 浏览器会选择最接近设备 DPR 的图片（不小于设备 DPR 且尽可能接近），所以会选择 `600w` 对应的 `img@2x.jpg`



**假设视口宽度为 `375px`，DPR = 3**

1. 依然计算出展示宽度为 `300px`
2. 与 `srcset` 中候选资源比值
   1. `300w / 300px = 1`
   2. `600w / 300px = 2`
   3. `1200w / 300px = 4`
3. 因为 `600w` 的 DPR = 2 不足以满足设备 DPR，浏览器会选择**最接近但不小于 3 的图片**，即 `1200w`，也就是 `img@3x.jpg`



**假设视口宽度为 `1280px`，DPR = 1**

1. 先计算出展示宽度为 `600px`
2. 与 `srcset` 中候选资源比值
   1. `300w / 600px = 0.5`
   2. `600w / 600px = 1`
   3. `1200w / 600px = 2`
3. 因为设备 DPR = 1，所以选择 `600w`，即 `img@2x.jpg`



## 简化计算

在实际开发中，我们如果每次都手动将 `px` 转换为 `rem` 或者 `vm`，肯定会影响开发效率，有以下三种方式简化计算步骤：

1. **使用代码编辑器扩展**，例如 VS Code 上的扩展 [px to rem & rpx & vw (cssrem)](https://marketplace.visualstudio.com/items/?itemName=cipchk.cssrem) 或者 JetBrains IDE 上的扩展 [px2rem](https://plugins.jetbrains.com/plugin/11187-px2rem)

   ![image-20250504184308286](images/image-20250504184308286.png)

2. **使用 CSS 预处理器**，如：Scss 或者 Less

   - `rem` 方案

     ```scss
     // 假设设计稿的宽度是 375px，假设取设计稿宽度下 1rem = 37.5px （375px 平分为 10 份）
     $baseFontSize: 37.5;
     
     @function px2rem($px) {
     	@return $px / $baseFontSize * 1rem;
     }
     ```

   - `vw` 方案

     ```scss
     // 假设设计稿的宽度是 375px
     $baseWidth: 375;
     
     @function px2vw($px) {
     	@return $px / $baseWidth * 100vw;
     }
     ```

3.  **使用 PostCSS 插件（推荐）**

   - [postcss-pxtorem](https://github.com/cuth/postcss-pxtorem) 插件：会自动将 CSS 文件中的转换为 `px` 单位转换为 `rem` 单位
   - [postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport) 插件：会自动将 CSS 文件中的转换为 `px` 单位转换为 `vw` 单位
